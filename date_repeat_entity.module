<?php

/**
 * @file
 * Adds functionality to entities with repeating date fields
 */
/*
 * Define field names necessary for module to function.
 */
define('FIELD_MASTER_UUID', 'field_master_uuid');
define('FIELD_CLONE_STATE', 'field_clone_state');

/**
 * Implements hook_form_alter().
 */
function date_repeat_entity_form_alter(&$form, &$form_state, $form_id) {

  // Check if the form is a node edit form
  if (!empty($form['#node_edit_form'])) {

    $entity_type = $form['#entity_type'];
    $bundle = $form['#bundle'];

    // Make sure utility functions are available.
    module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

    // Check if the entity attached to the form has a repeating date field.
    $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

    // Check if the entity also has other fields required for this module to
    // function properly.
    $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
    $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

    if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL
    ) {

      // Hide the clon/e state from the event edit form.
      if (isset($form['field_clone_state'])) {
        $form['field_clone_state']['#access'] = FALSE;
      }

      // Hide the master UUID from the event edit form.
      if (isset($form['field_master_uuid'])) {
        $form['field_master_uuid']['#access'] = FALSE;
      }

      // Check if the node exists i.e. form is in edit mode.
      if (isset($form['nid']['#value'])) {

        // Prepend a callback to preview action callbacks.
        array_unshift($form['actions']['preview']['#submit'], 'date_repeat_entity_preview_handler');

        // If it exists, prepend the same callback to the preview_changes action.
        // see the Diff module.
        if (isset($form['actions']['preview_changes'])) {
          array_unshift($form['actions']['preview_changes']['#submit'], 'date_repeat_entity_preview_handler');
        }

        // Store the form's default submit action callbacks for node updates.
        if (!isset($form_state['default_update_callbacks'])) {
          $form_state['default_update_callbacks'] = $form['actions']['submit']['#submit'];
        }

        // Change callback for submit button
        $form['actions']['submit']['#submit'] = array('date_repeat_entity_update_submit_handler');

        // Store the form's default delete action callbacks.
        if (!isset($form_state['default_delete_callbacks'])) {
          //$form_state['default_delete_callbacks'] = $form['actions']['delete']['#submit'];
          // Note: use empty array because we don't actually want to keep the default
          // submit handler that redirects to the node delete confirmation form.
          $form_state['default_delete_callbacks'] = array();//$form['actions']['delete']['#submit'];
        }
        
        // Change callback for delete button
        $form['actions']['delete']['#submit'] = array('date_repeat_entity_delete_submit_handler');
        
        // Check if form is in save confirmation state:
        if (isset($form_state['node_confirmation_action'])) {

          // Add fieldset containing confirmation buttons.
          add_confirmation_button_fieldset($form, $form_state);
        }
      }
    }
  }
}

/**
 * Add a field set containing confirmation buttons to the top of a form.
 *
 * @param type $form
 *   The form object that is being built
 */
function add_confirmation_button_fieldset(&$form, $form_state) {

  $action = $form_state['node_confirmation_action'];
  
  // Get the default submit callbacks.
  $submit_callbacks = $form_state['default_' .$action . '_callbacks'];

  // Prepend a callback to submit_callbacks.
  array_unshift($submit_callbacks, 'date_repeat_entity_' .$action . '_dates');

  // Get title field weight because we want our fieldset
  // and its confirmation buttons to be above the form title,
  // which has a weight of -5 by default.
  // see @node.pages.inc
  $title_field_weight = $form['title']['#weight'];

  // Set a weight for the fieldset
  $fieldset_weight = $title_field_weight - 10;

  // Define the fieldset
  $form['update-buttons'] = array(
    '#type' => 'fieldset',
    '#title' => t('Confirm ' . $action),
    '#weight' => $fieldset_weight,
  );

  $update_buttons_element_weight = 0;

  // Determine if there any references entities that will be affected by
  // update.
  $referenced_entities = get_referenced_entities($form, $form_state);
  if (!empty($referenced_entities)) {

    // Create a warning message.
    $referenced_entities_message = "";
    foreach ($referenced_entities as $referenced_entity) {

      $number_of_reference_entities = $referenced_entity['number_of_referenced_entities'];
      $entity_label = $referenced_entity['entity_label'];

      $referenced_entities_message .= '<p>There ';
      $referenced_entities_message .= ($number_of_reference_entities > 1) ? 'are ' : 'is ';

      // Print a warning message about the entities that may be affected by update.
      $referenced_entities_message .= t(
        '@number_of_referenced_entities referenced @entity_label that may be affected by this update', array(
        '@number_of_referenced_entities' => $number_of_reference_entities,
        '@entity_label' => $entity_label,
          )
      );
      $referenced_entities_message .= '.</p>';
    }
    
    // Add markup for warning message to form.
    $update_buttons_element_weight++;
    $form['update-buttons']['update-text'] = array(
      '#markup' => $referenced_entities_message,
    );
  }

  // Create button that gives user option of updating current and future
  // dates associated with an entity.  Prepend our callback to the
  // default submit action callbacks.
  $update_buttons_element_weight++;
  $form['update-buttons']['update-current'] = array(
    '#type' => 'submit',
    '#value' => $action,
    '#name' => 'update_current',
    '#submit' => $submit_callbacks,
    '#validate' => array(),
    '#weight' => $update_buttons_element_weight,
  );

  // Get the ids of all entities with same master uuid.
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $entity = $form['#entity'];
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  
  // Get the master uuid value.
  $master_uuid = $wrapper->field_master_uuid->value();
  
  // Get related ids
  $related_entity_ids = _get_related_entity_ids($entity_type, $bundle, $master_uuid);

  // If there are related entities we need to give options to user.
  if (count($related_entity_ids) > 1) {

    // Update default save confirmation button.
    $form['update-buttons']['update-current']['#value'] = $action . t(' current');

    // Create button that gives user option of updating current and future
    // dates associated with an entity.  Prepend our callback to the
    // default submit action callbacks.
    $update_buttons_element_weight++;
    $form['update-buttons']['update-future'] = array(
      '#type' => 'submit',
      '#value' => $action . t(' all following'),
      '#name' => 'update_future',
      '#submit' => $submit_callbacks,
      '#validate' => array(),
      '#weight' => $update_buttons_element_weight,
    );

    // Create button that gives user option of updating all dates associated
    // with an entity.  Prepend our callback to the default submit action
    // callbacks.
    $update_buttons_element_weight++;
    $form['update-buttons']['update-all'] = array(
      '#type' => 'submit',
      '#value' => $action . t(' all events in the series'),
      '#name' => 'update_all',
      '#submit' => $submit_callbacks,
      '#validate' => array(),
      '#weight' => $update_buttons_element_weight,
    );
  }

  // Create button that gives user option of cancelling updates
  $update_buttons_element_weight++;
  $form['update-buttons']['update-cancel'] = array(
    '#type' => 'submit',
    '#value' => t('cancel ' . $action),
    '#name' => 'update_cancel',
    '#submit' => array('date_repeat_entity_update_dates_cancel'),
    '#validate' => array(),
    '#weight' => $update_buttons_element_weight,
  );
}

/**
 * Submit handler for the 'submit' action (on existing nodes).
 */
function date_repeat_entity_update_submit_handler($form, &$form_state) {
  date_repeat_entity_submit_handler($form, $form_state, 'update');
}

/**
 * Submit handler for the 'delete' action.
 */
function date_repeat_entity_delete_submit_handler($form, &$form_state) {
  date_repeat_entity_submit_handler($form, $form_state, 'delete');
}

/**
 * Submit handler for the 'submit' and 'delete' actions.
 */
function date_repeat_entity_submit_handler($form, &$form_state, $action) {

  // Remove preview markup if form was in preview mode.
  if (isset($form_state['node_preview'])) {
    unset($form['#prefix']);
    unset($form_state['node_preview']);
    unset($form['#node']->in_preview);
  }

  // Set node confirmation status.
  $form_state['node_confirmation_action'] = $action;
  $form_state['rebuild'] = TRUE;
}        

/**
 * Submit handler for the 'preview' action.
 */
function date_repeat_entity_preview_handler($form, &$form_state) {

  // Remove node confirmation from form state.
  if (isset($form_state['node_confirmation_action'])) {
    unset($form_state['node_confirmation_action']);
  }
}

function date_repeat_entity_update_dates($form, &$form_state) {

  $form_state['values']['date_repeat_entity']['action'] = $form_state['node_confirmation_action'];
  
  unset($form_state['node_confirmation_action']);

  $trigger = $form_state['triggering_element']['#name'];

  // Store the name of the button that was pressed in a form_state values
  // property.
  $form_state['values']['date_repeat_entity']['triggering_element'] = $trigger;

  // Make sure repeating date update functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.update');

  // Determine if the repeating date has materially changed.
  $form_state['values']['date_repeat_entity']['repeating_date_has_changed'] = _repeating_date_has_changed($form, $form_state);
}

function date_repeat_entity_delete_dates($form, &$form_state) {

  $form_state['values']['date_repeat_entity']['action'] = $form_state['node_confirmation_action'];
  
  unset($form_state['node_confirmation_action']);

  $trigger = $form_state['triggering_element']['#name'];

  // Store the name of the button that was pressed in a form_state values
  // property.
  $form_state['values']['date_repeat_entity']['triggering_element'] = $trigger;

  // Make sure repeating date delete functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.delete');
  
  // Get entity 
  $entity_type = 'node';
  delete_dates($form['#entity'], $entity_type, $trigger);

}

function date_repeat_entity_update_dates_cancel(&$form, &$form_state) {

  // Remove update buttons fieldset.
  unset($form['update-buttons']);

  // Unset node confirmation status.
  unset($form_state['node_confirmation_action']);
  
  // Rebuild form
  $form_state['rebuild'] = TRUE;
}

/**
 * Implements hook_entity_presave().
 *
 * When a new entity is created we need this hook because it is called
 * after the entity object is created but before it is saved to the database.
 */
function date_repeat_entity_entity_presave($entity, $entity_type) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date create functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.create');

  // Get entity wrapper.
  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Get bundle type.
  $bundle = $wrapper->getBundle();

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

  // Check if the entity also has other fields required for this module to
  // function properly.
  $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
  $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

  if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL) {
    if ($entity->is_new) {
      create_dates($entity, $entity_type);
    }
    else {

      // TODO: implement
      //
      // the function will have to delete future/all entities and then recreate
      // a new series with new master_uuid
      update_dates($entity, $entity_type);
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 */
function date_repeat_entity_entity_delete($entity, $entity_type) {
  
  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date delete functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.delete');

  // Get entity wrapper.
  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Get bundle type.
  $bundle = $wrapper->getBundle();

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

  // Check if the entity also has other fields required for this module to
  // function properly.
  $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
  $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

  if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL) {
      //delete_dates($entity, $entity_type);
  }
}

/**
 * Alters the core node_delete_confirm form.
 *
 * Function called when user clicks Delete button on node edit form.
 *
 * Checks if the entity:
 *   a) represents a recurring field and,
 *   b) TODO: if there are entities that reference the entity.
 *
 * Provides options for deletion i.e. single instance current and future dates
 * or all dates.
 */
function date_repeat_entity_form_node_delete_confirm_alter(&$form, &$form_state, $form_id) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date delete functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.delete');

  // Check if the form contains a repeating date field.
  $entity_type = 'node';
  $node = $form['#node'];
  $bundle = $node->type;

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

  // Check if the entity also has other fields required for this module to
  // function properly.
  $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
  $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

  if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL) {

    drupal_set_title(t('Delete Recurring Event'), PASS_THROUGH);

    $form['description'] = array(
      '#type' => 'item',
      '#title' => t('Would you like to delete only this event, all events in the series, or this and all future events in the series?  Deleting this event may affect related attendance information.'),
    );

    // Change title of default submit button.
    // Only this instance (all other events in the series will remain).
    // Note: the default handler will remain for this button
    // i.e. node_delete_form_submit
    $form['actions']['submit']['#value'] = t('Only this instance');
    $form['actions']['submit']['#weight'] = 10;

    // Create button that gives user option of deleting current and future
    // dates associated with an entity.
    // All following (this and all the following events will be deleted).
    $form['actions']['delete-future'] = array(
      '#type' => 'submit',
      '#value' => t('All following'),
      //'#submit' => array_merge(array('delete_future_dates'), $form['#submit']),
      '#submit' => array('delete_future_dates'),
      '#weight' => 20,
      '#validate' => array(),
    );

    // Create button that gives user option of deleting all dates associated
    // with an entity.
    // All events in the series (all events in the series will be deleted).
    $form['actions']['delete-all'] = array(
      '#type' => 'submit',
      '#value' => t('Delete all events in the series'),
      //'#submit' => array_merge(array('delete_all_dates'), $form['#submit']),
      '#submit' => array('delete_all_dates'),
      '#weight' => 30,
      '#validate' => array(),
    );

    // Send user back to node edit page if they cancel delete form.
    $nid = $form['nid']['#value'];
    $form['actions']['#href'] = 'node/' . $nid . '/edit';
    $form['actions']['cancel']['#weight'] = 40;
  }
}

function get_referenced_entities($form, $form_state) {

  $referenced_entities = array();

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];

  // Get an array of field objects which are entity reference types.
  $entity_reference_fields = _get_entity_reference_fields($entity_type, $bundle);

  // Loop over entity reference field instances to get number of
  // referenced entities.
  foreach ($entity_reference_fields as $field) {

    // Get field name.
    $field_name = $field['field_name'];

    // Get meta data properties of the field instance.
    $info = field_info_instance($entity_type, $field_name, $bundle);

    // Reset entity counter
    $number_of_referenced_entities = 0;

    // Methods of retrieving child entities depend on widget type.
    switch ($info['widget']['type']) {

      case 'inline_entity_form':
        // An inline entity form widget is being used for this instance.
        // The IEF entities are stored in a specific branch of the form_state
        // array.
        $ief_id = $info['id'];
        // If the inline entity form widget is being used to control entity
        // references check how many entities are attached to it.
        foreach ($form_state['inline_entity_form'][$ief_id]['entities'] as $ief_entity) {
          $number_of_referenced_entities++;
        }
        break;
      default:
        // Other widgets store referenced field entities in the form_state values
        // array.
        foreach ($form_state['values'][$field_name][LANGUAGE_NONE] as $target_entity) {
          if (!is_null($target_entity['target_id'])) {
            $number_of_referenced_entities++;
          }
        }
    }

    // Add to the array of referenced entities if any were identified.
    if ($number_of_referenced_entities > 0) {

      $referenced_entities[] = array(
        'entity_label' => $info['label'],
        'number_of_referenced_entities' => $number_of_referenced_entities,
      );
    }
  }

  return $referenced_entities;
}