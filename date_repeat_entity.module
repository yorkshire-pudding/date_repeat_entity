<?php

/**
 * @file
 * Allows repeating date fields to be managed in entities
 */

/**
 * Implements hook_menu().
 */
function date_repeat_entity_menu() {
  $items = array();

  // Create routing for the node save confirmation form.
  $items['node/%node/save-confirm'] = array(
    'title' => 'Save Confirmation',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('date_repeat_entity_node_save_confirm', 1),
    'description' => 'A confirmation form for saving event nodes',
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function date_repeat_entity_admin_paths() {

  // If the site is configured to use a different theme for administration
  // then this hook provides a list of paths where the administration theme
  // should be used.
  if (variable_get('node_admin_theme')) {
    $paths = array(
      'node/*/save-confirm' => TRUE,
    );
    return $paths;
  }
}

/**
 * Implements hook_form_alter().
 */
function date_repeat_entity_form_event_node_form_alter(&$form, &$form_state, $form_id) {

  // Check if the form contains a repeating date field.
  $entity_type = $form['#entity_type'];
  $bundle_type = $form['#bundle'];

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle_type);

  if ($repeating_date_field != NULL) {

    // Add hidden field to form.
    $repeating_date_field_name = $repeating_date_field['field_name'];
    $form['repeating_date_field'] = array('#type' => 'hidden', '#value' => $repeating_date_field_name);

    // Hide the clone state from the event edit form.
    $form['field_clone_state']['#access'] = FALSE;

    // Hide the master UUID from the event edit form.
    $form['field_master_uuid']['#access'] = FALSE;

    // Add custom validation
    $form['#validate'][] = 'date_repeat_entity_validate';

    // If the entity is being updated (i.e. not created for first time)
    // then replace default node submit handler with custom handler.
    if (isset($form['nid']['#value'])) {

      // Replace core node submit handler with handler.
      // Note: this requires an explicit call to the core node submit handler
      // after this module's functions have been called.
      $form['actions']['submit']['#submit'] = array('date_repeat_entity_node_save');
    }
  }
}

/**
 * Provides custom validation for entities that have repeating date fields.
 *
 * @param object $form
 *   defines form structure.
 * @param array $form_state
 *   defines form state at validation time including the values entered by user.
 */
function date_repeat_entity_validate(&$form, &$form_state) {

  // Not currently used because validation moved to separate confirmation
  // form.
}

/**
 * Checks if an entity with a repeating date has changed.
 * 
 * Compares the start date, end date and RRULE of new and old entity .
 * 
 * @return bool
 *   TRUE if the repeating date has changed.
 */
function _repeating_date_has_changed(&$form, &$form_state) {

  $repeating_date_has_changed = FALSE;

  // Check that entity aleady exists - we are not validating new entities.
  if ($form_state['values']['changed'] != "") {

    // Check that the entity form has a repeating date field and a field that
    // controls the scope of changes to an entity e.g. All, Future, Single.
    $entity_type = $form['#entity_type'];
    $bundle_type = $form['#bundle'];

    // Make sure utility functions are available.
    module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');
    $repeating_date_field = _get_repeating_date_field($entity_type, $bundle_type);

    if ($repeating_date_field != NULL) {

      // Get the name of the repeating field.
      $repeating_date_field_name = $repeating_date_field['field_name'];
      $language = $form_state['values']['language'];

      $new_date_start_value = $form_state['values'][$repeating_date_field_name][$language][0]['value'];
      $new_date_end_value = $form_state['values'][$repeating_date_field_name][$language][0]['value2'];
      $new_rrule = $form_state['values'][$repeating_date_field_name][$language][0]['rrule'];
      $new_repeat_date_start_value = $form_state['values']['field_repeat_start_date'][$language][0]['value'];

      $entity_id = $form['#entity']->nid;
      $old_entity = entity_load_unchanged($entity_type, $entity_id);

      // TODO: replace field_date with the abstracted field name
      // $repeating_date_field_name.
      $old_date_start_value = $old_entity[$repeating_date_field_name][$old_entity->language][0]['value'];
      $old_date_end_value = $old_entity->field_date[$old_entity->language][0]['value2'];
      $old_rrule = $old_entity->field_date[$old_entity->language][0]['rrule'];
      $old_repeat_date_start_value = $old_entity->field_repeat_start_date[$old_entity->language][0]['value'];

      // Check if the entity date has changed to the extent that
      // the repeating date series has changed and therefore dependent data
      // like date exceptions and referencing entities will need to be reset.
      $new_date_data = array(
        $new_date_start_value,
        $new_date_end_value,
        $new_rrule,
        $new_repeat_date_start_value,
      );

      $old_date_data = array(
        $old_date_start_value,
        $old_date_end_value,
        $old_rrule,
        $old_repeat_date_start_value,
      );

      if ($new_date_data !== $old_date_data) {
        $repeating_date_has_changed = TRUE;
      }
    }
  }
  return $repeating_date_has_changed;
}

/**
 * Alters the node_delete_confirm form.
 * 
 * Function called when event node is about to be deleted.
 *
 * Checks if the entity:
 *   a) represents a recurring field and,
 *   b) if there are entities that reference the entity.
 *
 * If so, then we need to provide more options for deletion i.e. single instance
 * current and future dates or all dates.
 */
function date_repeat_entity_form_node_delete_confirm_alter(&$form, &$form_state, $form_id) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date update functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.delete');

  drupal_set_title(t('Delete Recurring Event'), PASS_THROUGH);

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Would you like to delete only this event, all events in the series, or this and all future events in the series?  Deleting this event may affect related attendance information.'),
  );

  // Change title of default submit button.
  // Only this instance (all other events in the series will remain).
  $form['actions']['submit']['#value'] = t('Only this instance');
  $form['actions']['submit']['#weight'] = 10;

  // Create button that gives user option of deleting current and future
  // dates associated with an entity.
  // All following (this and all the following events will be deleted).
  $form['actions']['delete-future'] = array(
    '#type' => 'submit',
    '#value' => t('All following'),
    '#submit' => array_merge(array('delete_future_dates'), $form['#submit']),
    '#weight' => 20,
    '#validate' => array(),
  );

  // Create button that gives user option of deleting all dates associated
  // with an entity.
  // All events in the series (all events in the series will be deleted).
  $form['actions']['delete-all'] = array(
    '#type' => 'submit',
    '#value' => t('Delete all events in the series'),
    '#submit' => array_merge(array('delete_all_dates'), $form['#submit']),
    '#weight' => 30,
    '#validate' => array(),
  );

  // Send user back to node edit page if they cancel delete form.
  $nid = $form['nid']['#value'];
  $form['actions']['#href'] = 'node/' . $nid . '/edit';
  $form['actions']['cancel']['#weight'] = 40;
}

/**
 * Submit handler for entity forms with repeating dates.
 */
function date_repeat_entity_node_save($form, &$form_state) {

  $destination = array();
  if (isset($_GET['destination'])) {
    $destination = drupal_get_destination();
    unset($_GET['destination']);
  }
  $node = $form['#node'];

  if (_repeating_date_has_changed($form, $form_state) == TRUE) {

    // If repeating date has changed then we need to redirect user to custom
    // form with additional options for type of save i.e. current, future, all.
    if (!empty($form['nid']['#value'])) {
      $form_state['redirect'] = array('node/' . $node->nid . '/save-confirm', array('query' => $destination));
    }
  }
  else {
    // Save node normally.
  }
}

/**
 * Form constructor for the custom node save confirmation form.
 */
function date_repeat_entity_node_save_confirm($form, &$form_state, $node) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date update functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.update');

  drupal_set_title(t('Save Recurring Event'), PASS_THROUGH);

  $form['#node'] = $node;
  // Always provide entity id in the same form key as in the entity edit form.
  $form['nid'] = array('#type' => 'value', '#value' => $node->nid);

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Would you like to update only this event, all events in the series, or this and all future events in the series?  Updating this event may affect related attendance information.'),
  );

  // Create button that gives user option of updating the current date only.
  // dates associated with an entity.
  $form['actions']['update-current'] = array(
    '#type' => 'submit',
    '#value' => t('Only this instance'),
    '#submit' => array('update_current_date'),
    '#validate' => array(),
    '#weight' => 10,
  );

  // Create button that gives user option of updating current and future
  // dates associated with an entity.
  $form['actions']['update-future'] = array(
    '#type' => 'submit',
    '#value' => t('All following'),
    '#submit' => array('update_future_dates'),
    '#validate' => array(),
    '#weight' => 20,
  );

  // Create button that gives user option of updating all dates associated
  // with an entity.
  $form['actions']['update-all'] = array(
    '#type' => 'submit',
    '#value' => t('Update all events in the series'),
    '#submit' => array('update_all_dates'),
    '#validate' => array(),
    '#weight' => 30,
  );

  // Cancel link that takes user back to form in edit mode.
  $form['actions']['cancel'] = array(
    '#type' => 'link',
    '#title' => 'Cancel',
    '#href' => 'node/' . $node->nid . '/edit',
    '#weight' => 40,
  );

  return $form;
}

/**
 * Implements hook_entity_presave().
 */
function date_repeat_entity_presave($entity, $entity_type) {

  // TODO: turn this back on again after we determine how to avoid calling it
  // when a user is saving from the node edit form - which has its own hooks
  // and workflow.
  // 
  // At a minimum maybe we should cancel the save operation and force user
  // to change dates via node edit forms.
  // 
  // date_repeat_entity_update($entity, $entity_type);
}
