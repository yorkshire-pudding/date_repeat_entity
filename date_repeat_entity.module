<?php

/**
 * @file
 * Allows repeating date fields to be managed in entities
 */

/**
 * Implements hook_entity_presave().
 */
function date_repeat_entity_presave($entity, $entity_type) {

  // Get entity wrapper.
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  $entity_id = $wrapper->getIdentifier();
  $bundle_type = $wrapper->getBundle();

  // Check that the entity is of type "node" and bundle of type event
  // We have to do this because we are dependent on field_clone_date and
  // master_uuid, both fields that are tied to event bundles.
  if ($entity_type === 'node') {

    // Process event nodes - ideally we should be able to work on bundles
    // any time but the field_clone_state is part of the event bundle so
    // we need to test for the 'event' bundle type.
    if ($bundle_type === 'event') {

      // Get value of clone state - a new event node will have the default state
      // of FALSE while a cloned event node will have a state of TRUE.
      $field_clone_state = $wrapper->field_clone_state->value();

      // Clone the new entity and its attached fields using Replicate API
      // module.
      if ($field_clone_state === FALSE) {

        // If the current entity contains a repeating date field then
        // we need to process the entity.
        $field = get_repeating_date_field($entity_type, $bundle_type);

        if ($field != NULL) {
          // If this is a new event, create a clone of the entity for
          // each date instance in the series (except the first, which
          // will be saved at the end of this routine.
          if ($entity->is_new) {

            // Get the UUID from the master (original) date.
            $master_uuid = $wrapper->uuid->value();

            // Assign the UUID to the master UUID field.
            // Give the original entity a reference to its own UUID.
            // This will be needed for any updates of the recurring date series.
            $wrapper->field_master_uuid = $master_uuid;

            // Get an array of field data for the current entity.
            $field_name = $field['field_name'];
            $field_data = field_get_items($entity_type, $entity, $field_name);

            // Create a new set of dates by removing the first item in
            // the array - since it is the original (master) entity.
            array_shift($field_data);

            // Clone a new entity for each date in series
            // (except original entity).
            foreach ($field_data as $delta => $datum) {

              // Clone entity.
              $clone_entity = replicate_clone_entity($entity_type, $entity);

              // Get entity wrapper for the cloned node.
              $clone_wrapper = entity_metadata_wrapper($entity_type, $clone_entity);

              // Flag the node as cloned.
              $clone_wrapper->field_clone_state = TRUE;

              // Amend the title to indicate it has been cloned
              // e.g. add the start datetime of the date instance to the
              // title.
              // TODO *** remove in production code ***
              $clone_start_time = $datum['value'];
              $clone_wrapper->title = $wrapper->label() . " clone " . $clone_start_time;

              // Give the cloned entity a reference to the master UUID.
              $clone_wrapper->field_master_uuid = $master_uuid;

              // Reset the UUID, version UUID and version log string
              // of the cloned entity to differentiate from the
              // original entity.
              $clone_entity->uuid = NULL;
              $clone_entity->vuuid = NULL;
              $clone_entity->log = "cloned from uuid : " . $master_uuid;

              // Replace field array with the row that matches the
              // current delta.  Need to add an offset of 1 to delta
              // because delta values are shifted when we applied
              // array_shift to field_data.
              $clone_entity->field_date[$entity->language] = array_slice($clone_entity->field_date[$entity->language], $delta + 1, 1);

              // Save the cloned entity.
              entity_save($entity_type, $clone_entity);
            }
            // Remove all items from the master entity's field array
            // except the first.
            array_splice($entity->field_date[$entity->language], 1);
          }
          // If this an existing event that is being updated, update each
          // instance in the series as required.
          else {

            // Remove all items from the entity's field array except the
            // first.
            array_splice($entity->field_date[$entity->language], 1);

            /*
             * Check if certain properties and fields have changed that
             * require an update of related entities within repeating
             * date pattern.  These fields include:
             *
             * - title
             * - field_repeat_start_date (start date of the series)
             * - field_date value (start date)
             * - field_date value2 (end date)
             * - field_date rrule (recurrence rule)
             */

            // Get title property.
            $new_title = $wrapper->label();

            // Get field data for newly updated entity.
            // Note : using EntityDataWrapper to retrieve datetime values
            // returns integer instead of the format used in datetime column si
            // alternate method using $entity is needed.
            $new_date_start_value = $entity->field_date[$entity->language][0]['value'];
            $new_date_end_value = $entity->field_date[$entity->language][0]['value2'];
            $new_repeat_date_start_value = $entity->field_repeat_start_date[$entity->language][0]['value'];

            // Get rrule.
            // Note : using EntityDataWrapper to retrieve the string
            // from the rrule field results in an exception thrown so
            // alternate method using $entity is needed.
            $new_rrule = $entity->field_date[$entity->language][0]['rrule'];

            // Get field data for original entity.
            $old_entity = entity_load_unchanged($entity_type, $entity_id);
            $old_wrapper = entity_metadata_wrapper($entity_type, $old_entity);
            $old_title = $old_wrapper->label();

            // Get field data for newly updated entity.
            // Note : using EntityDataWrapper to retrieve datetime values
            // returns integer instead of the format used in datetime column si
            // alternate method using $entity is needed.
            $old_date_start_value = $old_entity->field_date[$old_entity->language][0]['value'];
            $old_date_end_value = $old_entity->field_date[$old_entity->language][0]['value2'];
            $old_repeat_date_start_value = $old_entity->field_repeat_start_date[$old_entity->language][0]['value'];

            // Get rrule.
            // Note : using EntityDataWrapper to retrieve the string
            // from the rrule field results in an exception thrown so
            // alternate method using $entity is needed.
            $old_rrule = $old_entity->field_date[$old_entity->language][0]['rrule'];

            // Check if the entity date has changed to the extent that
            // updates to other date instances in the series are
            // required.
            $new_date_data = array($new_title,
              $new_date_start_value,
              $new_date_end_value,
              $new_repeat_date_start_value,
              $new_rrule);
            $old_date_data = array($old_title,
              $old_date_start_value,
              $old_date_end_value,
              $old_repeat_date_start_value,
              $old_rrule);

            // Conservatively assume that the date _has_ changed.
            $entity_date_changed = TRUE;
            if ($new_date_data == $old_date_data) {
              $entity_date_changed = FALSE;
            }
            if ($entity_date_changed) {

              /*
               * Determine extent to which changes are required.
               *
               * If $new_date_start_date
               *
               */

              // Get timezone associated with the field instance.
              $timezone = date_get_timezone($field['settings']['tz_handling']);

              // Create DateObjects (extensions of PHP DateTime objects)
              // from the new start date and old start date.
              $new_date_start = new DateObject($new_date_start_value, $timezone, date_type_format($field['type']));
              $new_date_end = new DateObject($new_date_end_value, $timezone, date_type_format($field['type']));
              $old_date_start = new DateObject($old_date_start_value, $timezone, date_type_format($field['type']));
              $old_date_end = new DateObject($old_date_end_value, $timezone, date_type_format($field['type']));

              // Create DateObjects from the series start and end dates.
              $new_repeat_date_start = new DateObject($new_repeat_date_start_value, $timezone, date_type_format($field['type']));

              // Return the time difference (seconds) between:
              // a) the new start date and old start date and
              // b) the new start date and new end date.
              $seconds_between_new_and_old_start_date = $new_date_start->difference($old_date_start);
              $seconds_between_new_start_and_new_end_date = $new_date_end->difference($new_date_start);

              // Define PHP Interval objects
              $interval_between_new_and_old_start_date = new DateInterval('PT' . $seconds_between_new_and_old_start_date . 'S');
              $interval_between_new_start_and_new_end_date = new DateInterval('PT' . $seconds_between_new_start_and_new_end_date . 'S');

              // Get the series master entity
              $master_uuid = $wrapper->field_master_uuid->value();

              $master_entity = _get_master_entity($entity_type, $bundle_type, $master_uuid);

              $master_date_start_value = $master_entity->field_date[$master_entity->language][0]['value'];
              //$master_date_end_value = $master_entity->field_date[$master_entity->language][0]['value2'];

              // Apply the offset to the series start date.
              if ($new_date_start > $old_date_start) {
                $new_repeat_date_start_calculated = $master_date_start_value->add($interval_between_new_and_old_start_date);
              }
              else {
                $new_repeat_date_start_calculated = $master_date_start_value->sub($interval_between_new_and_old_start_date);
              }

              // Apply the interval between the new start date and the new end date to the first date in the series.
              if ($new_date_end > $old_date_end) {
                $new_repeat_date_end_calculated = $master_date_end_value->add($interval_between_new_start_and_new_end_date);
              }
              else {
                $new_repeat_date_end_calculated = $master_date_end_value->sub($interval_between_new_start_and_new_end_date);
              }

              // Get formatted string representing new series start date and
              // end date.
              $new_repeat_date_start_calculated_value = date_format($new_repeat_date_start_calculated, date_type_format($field['type']));
              $new_repeat_date_end_calculated_value = date_format($new_repeat_date_end_calculated, date_type_format($field['type']));

              // Create an item array to simulate the field instance structure
              // used in Date module's Form API functions.
              $item = array('value' => $new_repeat_date_start_calculated_value,
                'value2' => $new_repeat_date_end_calculated_value,
                'timezone' => $timezone);

              // Get new date series
              $new_dates = date_repeat_build_dates($new_rrule, NULL, $field, $item);

              $date_entity_update_constraints = $wrapper->field_change_repeat_scope->value();

              switch ($date_entity_update_constraints) {
                case "All":
                  // Process all dates.
                  $updated_entity_values = _process_all_dates($entity, $entity_id, $new_dates, $entity_type, $bundle_type, $master_uuid);
                  break;

                case "Future":
                  // Process current and future dates.
                  break;

                case "Single":
                  // Process current date only.
                  _process_current_date_only($entity, $entity_id, $entity_type, $bundle_type, $master_uuid);
                  break;

                default:
                // Throw exception since every user response should
                // satisfy one of the above three constraints.
              }

              // Update the current entity based on any values returned from
              // _process_[function]
              if (isset($updated_entity_values) && $updated_entity_values != NULL) {
                $entity->field_date[$entity->language][0]['value'] = $updated_entity_values['value'];
                $entity->field_date[$entity->language][0]['value2'] = $updated_entity_values['value2'];
                $entity->field_date[$entity->language][0]['rrule'] = $updated_entity_values['rrule'];
                $entity->field_repeat_start_date[$entity->language][0]['value'] = $updated_entity_values['repeat_date_start_value'];
              }
            }
          }
        }
      }
    }
  }

  // Reset the flag for clone state, just before saving the entity.
  $entity->field_clone_state = FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Assumes an event bundle of entity type node, a field_clone_state and a
 * field_master_uuid all exist.
 */
function date_repeat_entity_form_event_node_form_alter(&$form, &$form_state, $form_id) {

  // Hide the clone state from the event edit form.
  $form['field_clone_state']['#access'] = FALSE;

  // Hide the master UUID from the event edit form.
  $form['field_master_uuid']['#access'] = FALSE;
}

/**
 * Process all dates associated with a repeating date series.
 */
function _process_all_dates($entity, $entity_id, $new_dates, $entity_type = 'node', $bundle = 'event', $master_uuid = NULL) {

  // Instantiate array to be returned.
  $updated_entity_values = array();

  // Use EFQ to update all dates with the same field_master_uuid value
  // keep the UUIDs but update the field_date multivalue fields for each
  // entity in the series.
  $query = new EntityFieldQuery();

  // Define EFQ conditions based on the entity type, bundle and master_uuid.
  $query->entityCondition('entity_type', $entity_type)
      ->entityCondition('bundle', $bundle)
      // Note: exclude current entity.
      // ->entityCondition('entity_id', array($entity_id), 'NOT IN')
      ->fieldCondition('field_master_uuid', 'value', $master_uuid, '=')
      // Sort by start date.
      ->fieldOrderBy('field_date', 'value', 'ASC');

  // Retrieve matching entities.
  $result = $query->execute();

  // If query successful, update retrieved entities.
  if (isset($result[$entity_type])) {

    // Retrieve RRULE for current entity.
    //$rrule = $entity->field_date[$entity->language][0]['rrule'];
    // Retrieve start date for current entity since this is being applied
    // to all dates by the user.
    //$start_date = $entity->field_date[$entity->language][0]['value'];
    //$end_date = $entity->field_date[$entity->language][0]['value2'];
    // Retrieve dates - note: date_repeat_calc returns sorted dates.
    // TODO: account for exceptions and additions as well as timezone.
    //$new_dates = date_repeat_calc($rrule, $start_date, NULL);
    // Build and array of entity ids for for the entity type.
    $date_entity_ids = array_keys($result[$entity_type]);

    // Retrieve entities based on entity ids.
    $date_entities = entity_load($entity_type, $date_entity_ids);

    // Update instances, where necessary...
    // From the Groupanizer 3 design docs:
    // Changing all instances will involve updating all instances represented
    // by the recurrence pattern.  Exceptions need not be updated.
    // In Google Calendar, if a recurrence pattern’s start date, start time
    // but not duration apparently) and/or frequency is modified then all the
    // properties of each exception will be changed to match the recurrence
    // pattern.  This includes recreation of instances that were previously
    // deleted exceptions. Google Calendar appears to employ a more subtle
    // approach i.e. if an instance’s field (title, start date, color etc.)
    // has been modified (i.e. it differs from that of the recurrence pattern,
    // then the modified field values will be preserved.  However, if they are
    // the same as the recurrence pattern then they will be changed to meet the
    // recurrence pattern.  After changes are applied to all instances, they
    // remain part of the original recurrence pattern.
    $updated_entity_values = array();

    // Dummy iterator because $date_entities keys are entity_ids
    // and $new_dates keys are numeric indices.
    $counter = 0;

    foreach ($date_entities as $delta => $date_entity) {

      // Get the start, end date and RRULE for this date_entity based on its
      // position in $new_dates array.
      $date_entity_start_date = $new_dates[$counter]['value'];
      $date_entity_end_date = $new_dates[$counter]['value2'];
      $date_entity_rrule = $new_dates[$counter]['rrule'];

      // Check if $date_entity (the $delta key is the entity_id) matches
      // the entity passed to this routine.
      if ($delta == $entity_id) {
        // The current $date_entity matches the one that was passed to this
        // routine so we need to avoid updating it in the middle of a save
        // operation.  Instead save the new values in an array that is returned
        // to the calling function.
        $updated_entity_values['value'] = $date_entity_start_date;
        $updated_entity_values['value2'] = $date_entity_end_date;
        $updated_entity_values['rrule'] = $date_entity_rrule;
      }
      else {

        // Set the entity title.
        $date_entity->title = $entity->title;

        // Set the start date.
        $date_entity->field_date[$entity->language][0]['value'] = $date_entity_start_date;

        // Set the end date.
        $date_entity->field_date[$entity->language][0]['value2'] = $date_entity_end_date;

        // Set the RRULE field value.
        $date_entity->field_date[$entity->language][0]['rrule'] = $date_entity_rrule;

        // Set clone state to TRUE so the cloning procedures are skipped
        // when hook_entity_presave is triggered.
        $date_entity->field_clone_state = TRUE;

        // Save the entity.
        entity_save($entity_type, $date_entity);
      }

      // Increment counter.
      $counter++;
    }
  }
  return $updated_entity_values;
}

/**
 * Process current and future dates associated with a repeating date series.
 */
function _process_current_and_future_dates() {
  // Use EFQ to update all dates with the same field_master_uuid value
  // and any dates that are later than $entity.
  // Since this entity and all future ones are eing changed it is assumed that
  // they are forming a new series (per Google and TeamSnap implementations)
  // and so new UUID will be required for this date and then the
  // field_master_uuid and the field_date multivalue fields will have to be
  // updated as well for each entity in the series.
}

/**
 * Process current date only from a repeating date series.
 */
function _process_current_date_only($entity, $entity_id, $entity_type = 'node', $bundle = 'event', $master_uuid = NULL) {
  // Use EFQ to update all dates with the same field_master_uuid value.
  // This may not be necessary as there are no other dates besides the
  // current entity.  However, since this is being changed it is assumed
  // that it is becoming an exception to the current series and will have
  // to be added to the exceptions rule in RRULE field for all related entities.
  $query = new EntityFieldQuery();

  // Define EFQ conditions based on the entity type, bundle and master_uuid.
  $query->entityCondition('entity_type', $entity_type)
      ->entityCondition('bundle', $bundle)
      ->fieldCondition('field_master_uuid', 'value', $master_uuid, '=');

  // Retrieve matching entities.
  $result = $query->execute();

  // If query successful, update retrieved entities.
  if (isset($result[$entity_type])) {

    // Retrieve RRULE for current entity.
    $rrule = $entity->field_date[$entity->language][0]['rrule'];

    // Retrieve start date for current entity since this is being applied
    // to all dates by the user.
    $start_date = $entity->field_date[$entity->language][0]['value'];

    // Retrieve dates.
    // TODO: account for exceptions and additions as well as timezone.
    $new_dates = date_repeat_calc($rrule, $start_date, NULL);

    // Build and array of entity ids for for the entity type.
    $date_entity_ids = array_keys($result[$entity_type]);

    // Retrieve entities based on entity ids.
    $date_entities = entity_load($entity_type, $date_entity_ids);

    // Update instances, where necessary...
    // From the Groupanizer 3 design docs:
    // Changing all instances will involve updating all instances represented
    // by the recurrence pattern.  Exceptions need not be updated.
    // In Google Calendar, if a recurrence pattern’s start date, start time
    // but not duration apparently) and/or frequency is modified then all the
    // properties of each exception will be changed to match the recurrence
    // pattern.  This includes recreation of instances that were previously
    // deleted exceptions. Google Calendar appears to employ a more subtle
    // approach i.e. if an instance’s field (title, start date, color etc.)
    // has been modified (i.e. it differs from that of the recurrence pattern,
    // then the modified field values will be preserved.  However, if they are
    // the same as the recurrence pattern then they will be changed to meet the
    // recurrence pattern.  After changes are applied to all instances, they
    // remain part of the original recurrence pattern.
    foreach ($date_entities as $date_entity) {

      // Set the RRULE field value.
      $date_entity->field_date[$entity->language][0]['rrule'] = $rrule;

      // Set the RRULE field value.
      $date_entity->field_date[$entity->language][0]['rrule'] = $rrule;

      // Set clone state to TRUE so the cloning procedures are skipped
      // when hook_entity_presave is triggered.
      $date_entity->field_clone_state = TRUE;

      // Save the entity.
      entity_save($entity_type, $date_entity);
    }
  }
}

/**
 * Returns a master entity from a master uuid
 */
function _get_master_entity($entity_type = 'node', $bundle = 'event', $master_uuid = NULL) {

  // Instantiate array to be returned.
  $master_entity = array();

  // Use EFQ to retrieve master entity.
  $query = new EntityFieldQuery();

  // Define EFQ conditions based on the entity type, bundle and master_uuid.
  $query->entityCondition('entity_type', $entity_type)
      ->entityCondition('bundle', $bundle)
      ->propertyCondition('uuid', $master_uuid);

  // Retrieve matching entities.
  $result = $query->execute();

  // If query successful, update retrieved entities.
  if (isset($result[$entity_type])) {

    // Get array of entity ids.
    $entity_ids = array_keys($result[$entity_type]);

    // Retrieve entities based on entity ids.
    $master_entities = entity_load($entity_type, $entity_ids);

    // Get first element in array (there should only be one)
    $master_entity = reset($master_entities);
  }

  return $master_entity;

}

/**
 * Returns the name of a repeating date field, where it exists.
 *
 * Searches database field definition for a repeating date field which is used
 * in the $entity_type (e.g. node) and $bundle_type (e.g. event) passed as
 * arguments.
 *
 * Note: Function returns once the first match of a repeating date field
 * is found and does not consider the scenario where there may be more than
 * one repeating date field associated with the $entity_type and $bundle_type.
 */
function get_repeating_date_field($entity_type, $bundle_type) {

  // Set a default value of NULL.
  $repeating_date_field = NULL;

  // Retrieve meta information about all of the fields in the database.
  $fields = field_info_fields();

  // Loop through the fields.
  foreach ($fields as $field_name => $field) {

    // Check if the field is a repeating date field.
    if (in_array($field['type'], array('date', 'datestamp', 'datetime')) && date_is_repeat_field($field)) {

      // Loop through the entity types associated with this field.
      foreach ($field['bundles'] as $field_entity_type => $bundles) {

        // Loop through the bundles (content types - in the case of node
        // entity types) associated with this entity type.
        foreach ($bundles as $field_bundle) {

          // If the entity type and bundle type passed to this function are the
          // same as the entity type and bundle of the repeating date field then
          // we have a match.
          if ($entity_type == $field_entity_type && $bundle_type == $field_bundle) {
            $repeating_date_field = $field;
            return $repeating_date_field;
          }
        }
      }
    }
  }
  return $repeating_date_field;
}
