<?php

/**
 * @file
 * Adds functionality to entities with repeating date fields
 */
/*
 * Define field names necessary for module to function. 
 */
define('FIELD_MASTER_UUID', 'field_master_uuid');
define('FIELD_CLONE_STATE', 'field_clone_state');

/**
 * Implements hook_form_alter().
 */
function date_repeat_entity_form_alter(&$form, &$form_state, $form_id) {

  // Check if the form is a node edit form
  if (!empty($form['#node_edit_form'])) {

    $entity_type = $form['#entity_type'];
    $bundle = $form['#bundle'];

    // Make sure utility functions are available.
    module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

    // Check if the entity attached to the form has a repeating date field.
    $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);
    
    // Check if the entity also has other fields required for this module to
    // function properly.
    $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
    $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

    if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL
    ) {

      // Hide the clone state from the event edit form.
      if (isset($form['field_clone_state'])) {
        $form['field_clone_state']['#access'] = FALSE;
      }

      // Hide the master UUID from the event edit form.
      if (isset($form['field_master_uuid'])) {
        $form['field_master_uuid']['#access'] = FALSE;
      }

      // Add  update option  buttons for existing nodes
      // (Determine if the entity is being updated.)
      if (isset($form['nid']['#value'])) {
        
        // Change default save button text
        $form['actions']['submit']['#value'] = t('Update just this event');
        $update_button_weight = $form['actions']['submit']['#weight'];

        // Create button that gives user option of updating current and future
        // dates associated with an entity.
        $form['actions']['update-future'] = array(
          '#type' => 'submit',
          '#value' => t('Update all following'),
          '#name' => 'future',
          '#submit' => array('update_dates'),
          '#validate' => array(),
          '#weight' => $update_button_weight + 1,
        );

        // Create button that gives user option of updating all dates associated
        // with an entity.
        $form['actions']['update-all'] = array(
          '#type' => 'submit',
          '#value' => t('Update all events in the series'),
          '#name' => 'all',
          '#submit' => array('update_dates'),
          '#validate' => array(),
          '#weight' => $update_button_weight + 2,
        );
      }
    }
  }
}

/**
 * Implements hook_entity_presave().
 * 
 * When a new entity is created we need this hook because it is called
 * after the entity object is created but before it is saved to the database.
 * (Updates to existing entities will be managed through submit handlers.)
 */
function date_repeat_entity_entity_presave($entity, $entity_type) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date create functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.create');

  // Get entity wrapper.
  $wrapper = entity_metadata_wrapper($entity_type, $entity);

  // Get bundle type.
  $bundle = $wrapper->getBundle();

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

  // Check if the entity also has other fields required for this module to
  // function properly.
  $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
  $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

  if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL) {
    if ($entity->is_new) {
      _create_dates($entity, $entity_type);
    }
  }
}

/**
 * Alters the core node_delete_confirm form.
 *
 * Function called when user clicks Delete button on node edit form.
 *
 * Checks if the entity:
 *   a) represents a recurring field and,
 *   b) TODO: if there are entities that reference the entity.
 *
 * Provides options for deletion i.e. single instance current and future dates
 * or all dates.
 */
function date_repeat_entity_form_node_delete_confirm_alter(&$form, &$form_state, $form_id) {

  // Make sure utility functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.utility');

  // Make sure repeating date update functions are available.
  module_load_include('inc', 'date_repeat_entity', 'includes/date_repeat_entity.delete');

  // Check if the form contains a repeating date field.
  $entity_type = 'node';
  $node = $form['#node'];
  $bundle = $node->type;

  // Check if the entity attached to the form has a repeating date field.
  $repeating_date_field = _get_repeating_date_field($entity_type, $bundle);

  // Check if the entity also has other fields required for this module to
  // function properly.
  $master_uuid_field = _get_field($entity_type, $bundle, FIELD_MASTER_UUID);
  $clone_state_field = _get_field($entity_type, $bundle, FIELD_CLONE_STATE);

  if ($repeating_date_field != NULL && $master_uuid_field != NULL && $clone_state_field != NULL) {

    drupal_set_title(t('Delete Recurring Event'), PASS_THROUGH);

    $form['description'] = array(
      '#type' => 'item',
      '#title' => t('Would you like to delete only this event, all events in the series, or this and all future events in the series?  Deleting this event may affect related attendance information.'),
    );

    // Change title of default submit button.
    // Only this instance (all other events in the series will remain).
    // Note: the default handler will remain for this button
    // i.e. node_delete_form_submit
    $form['actions']['submit']['#value'] = t('Only this instance');
    $form['actions']['submit']['#weight'] = 10;

    // Create button that gives user option of deleting current and future
    // dates associated with an entity.
    // All following (this and all the following events will be deleted).
    $form['actions']['delete-future'] = array(
      '#type' => 'submit',
      '#value' => t('All following'),
      //'#submit' => array_merge(array('delete_future_dates'), $form['#submit']),
      '#submit' => array('delete_future_dates'),
      '#weight' => 20,
      '#validate' => array(),
    );

    // Create button that gives user option of deleting all dates associated
    // with an entity.
    // All events in the series (all events in the series will be deleted).
    $form['actions']['delete-all'] = array(
      '#type' => 'submit',
      '#value' => t('Delete all events in the series'),
      //'#submit' => array_merge(array('delete_all_dates'), $form['#submit']),
      '#submit' => array('delete_all_dates'),
      '#weight' => 30,
      '#validate' => array(),
    );

    // Send user back to node edit page if they cancel delete form.
    $nid = $form['nid']['#value'];
    $form['actions']['#href'] = 'node/' . $nid . '/edit';
    $form['actions']['cancel']['#weight'] = 40;
  }
}
